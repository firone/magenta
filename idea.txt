generateur automatique de donnée, en créant un prototype. Les valeurs assignées indique le type de génération...

generateur prototype
user.setName(nameGenerator)

generateur manuel

generateur persistant (delegue à un autre generateur lorsque non dans le repository)

repository

use thread local for closure?

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Lazy initialiser les dataset?

fixtures().of(User.class).restrict(...) n'a aucun effet, ça ne fonctionne pas , car la fixtures est déjà associé au dataset dans le parent.  Il faudrait que la
fixture courante soit assigné dynamiquement,mais l'instance retourné doit être synchronisé avec tous les autres obtenus à une hiéarchie différent

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

Créer un random qui génère toujours la même séquence  -> les tests sont alors toujours reproductible

Utiliser une distribution qui pourrait être initialisé par une séquence.  On pourrait sauter au x élement à l'aide d'une system property.  Chaque fois que le fixtures
seraient créé, il y aurait un log indiquant le seed.

!!!!!!!
Lorsqu'on get un dataset du repo en utilisant une classe, est-ce que tous les datasets de ce type devrait être retourné? ou seulement celui spécifiquement associé?

Utiliser deux interfaces : DataSetGroup et GeneratorGroup qui serait passé tous les deux à la generation strategy.. comment appeler le dataset manager alors?

!!!!!!
Permettre d'ajouter des generateurs sans qu'il se retrouve aussi en dataset
Lancer une exception si l'appel a restrict contient des datasource inexistante, 
avoir un datasource du type empty(Class<C> clazz)
remplacer le restrict par directive?
Generaliser le concept de Directive?
Injection par annotation?


.......
Un generateur de polygon qui genere des polygones a partir d'une region donnee en la splittant en plusieurs parties



------------------
Une alternative au dataset, des callbacks? les strategies appeleraient directement les callbacks


Améliorer la hiearchie des StrategyAdapter -> il semble qu'il n'existe que deux types : single generator avec default number et  generateur fini de collections.  Faux, il est pratique que la
stratégie connaisse d'avance le nombre d'éléments à générer.


Faire une interface GenerationStrategy qui aurait différent adapteur -> set predefini, simple génération avec quantité par défaut et génération multiple avec quantité par défaut


------------------

Le relationMap doit être une cache gérer dynamiquement
ajouter des logs et donner un nom à chaque DomainDataManager... le nom pourrait être généré dans certain cas comme "restricted to (Country.USA) hockey data"
ajouter des augmenter ou modifier -> c'est l'equivalent d'une strategie ayant des affected dataset mais ne générant rien

Faire un random iterator pour le DataSetAggregationStrategy

//TODO : add a generatedBy from a list of generation strategy

//dont expose EventBus in the DataDomain

//les DataSet devraient presenter leur datakey
